package capabilities

import eu.nitok.jitsu.compiler.ast.ExpressionNode
import eu.nitok.jitsu.compiler.ast.StatementNode
import eu.nitok.jitsu.compiler.ast.TypeNode
import org.eclipse.lsp4j.DocumentSymbol
import org.eclipse.lsp4j.DocumentSymbolParams
import org.eclipse.lsp4j.SymbolInformation
import org.eclipse.lsp4j.SymbolKind
import org.eclipse.lsp4j.jsonrpc.messages.Either
import range
import java.util.concurrent.CompletableFuture

/**
 *
 * TODO: DO NOT! consider references but only declarations!
 *
 */


fun documentSymbols(node: StatementNode): List<DocumentSymbol> {
    return when (node) {
        is StatementNode.AssignmentNode -> listOf(
            DocumentSymbol(
                node.variable,
                SymbolKind.Variable,
                range(node.nameLocation),
                range(node.nameLocation),
                null,//TODO: add type
                mutableListOf()
            ),
            *documentSymbols(node.value).toTypedArray()
        )

        is StatementNode.CodeBlockNode.SingleExpressionCodeBlock -> documentSymbols(node.expression)
        is StatementNode.CodeBlockNode.StatementsCodeBlock -> node.statements.flatMap { documentSymbols(it) }
        is StatementNode.EnumDeclarationNode -> listOf(DocumentSymbol(
            node.name,
            SymbolKind.Enum,
            range(node.location),
            range(node.nameLocation),
            "enum ${node.name} (${node.constants.size} options)",
            node.constants.map {
                DocumentSymbol(
                    it.name,
                    SymbolKind.EnumMember,
                    range(it.location),
                    range(it.location),
                    "enum ${node.name}.${it}",
                    mutableListOf()
                )
            }
        ))

        is StatementNode.FunctionCallNode -> listOf(
            DocumentSymbol(
                node.function,
                SymbolKind.Function,
                range(node.location),
                range(node.nameLocation),
                "fn ${node.function} ())",//TODO improve
                node.parameters.flatMap { documentSymbols(it) }
            ),
            *node.parameters.flatMap { documentSymbols(it) }.toTypedArray()
        )

        is StatementNode.FunctionDeclarationNode -> listOf(
            DocumentSymbol(
                node.name ?: "anonymous\$${getArtificalId()}",
                SymbolKind.Function,
                range(node.location),
                range(node.location),
                "fn ${node.name} (${
                    node.parameters.map { "${it.name}: ${it.type}" }.joinToString(", ")
                } : ${node.returnType}",
                node.parameters.flatMap { documentSymbols(it) } + (node.returnType?.let{documentSymbols(it)}?: emptyList()) + documentSymbols(
                    node.body
                )
            )
        )

        is StatementNode.IfNode -> {
            val elseNodes = node.elseStatement?.let {
                when (it) {
                    is StatementNode.IfNode.ElseNode.ElseBlockNode -> documentSymbols(it.codeBlock)
                    is StatementNode.IfNode.ElseNode.ElseIfNode -> documentSymbols(it.ifNode)
                }
            } ?: emptyList();
            return (documentSymbols(node.condition) + documentSymbols(node.thenCodeBlockNode) + elseNodes)
        }

        is StatementNode.MethodInvocationNode ->
            documentSymbols(node.target) + listOf(DocumentSymbol(
                node.name,
                SymbolKind.Method,
                range(node.location),
                range(node.nameLocation),
                "SomeType.${node.name} (someArg: Int) : SomeType",//TODO improve
                node.parameters.flatMap { documentSymbols(it) } + documentSymbols(node.target)
            ))

        is StatementNode.ReturnNode -> node.expression?.let { documentSymbols(it) } ?: emptyList()
        is StatementNode.SwitchNode -> documentSymbols(node.item) + node.cases.flatMap { documentSymbols(it) }
        is StatementNode.TypeDefinitionNode -> listOf(
            DocumentSymbol(
                node.name,
                SymbolKind.Class,
                range(node.location),
                range(node.nameLocation),
                "type ${node.name} = ${node.type}",
                documentSymbols(node.type)
            )
        )

        is StatementNode.VariableDeclarationNode -> listOf(
            DocumentSymbol(
                node.name,
                SymbolKind.Variable,
                range(node.location),
                range(node.nameLocation),
                "var ${node.name} : ${node.type}",
                node.type?.let { documentSymbols(it) } ?: emptyList()
            ),
            *node.value?.let { documentSymbols(it) }?.toTypedArray() ?: emptyArray()
        )
    }
}

private fun documentSymbols(type: TypeNode): List<DocumentSymbol> {
    return when (type) {
        is TypeNode.ArrayTypeNode -> documentSymbols(type.type)
        is TypeNode.FloatTypeNode -> listOf()
        is TypeNode.IntTypeNode -> listOf()
        is TypeNode.NamedTypeNode -> listOf(DocumentSymbol(
            type.name,
            SymbolKind.Class,
            range(type.location),
            range(type.nameLocation),
            "${type.name}<${type.genericTypes.size} generics>",
            type.genericTypes.flatMap { documentSymbols(it) }
        ))

        is TypeNode.StringTypeNode -> listOf()
        is TypeNode.UnionTypeNode -> type.types.flatMap { documentSymbols(it) }
        is TypeNode.ValueTypeNode -> documentSymbols(type.value)
    }
}

private fun documentSymbols(it: StatementNode.SwitchNode.CaseNode): List<DocumentSymbol> {
    TODO()
}

private fun documentSymbols(param: StatementNode.FunctionDeclarationNode.ParameterNode): List<DocumentSymbol> {
    return listOf(
        DocumentSymbol(
            param.name,
            SymbolKind.Variable,
            range(param.location),
            range(param.nameLocation),
            "${param.name} : ${param.type}",
            documentSymbols(param.type) + (param.defaultValue?.let { documentSymbols(it) } ?: emptyList())
        )
    )
}

private fun documentSymbols(value: ExpressionNode): List<DocumentSymbol> {
    return when (value) {
        is ExpressionNode.BooleanLiteralNode -> listOf(
            DocumentSymbol(
                value.value.toString(),
                SymbolKind.Boolean,
                range(value.location),
                range(value.location),
                null,
                mutableListOf()
            )
        )

        is ExpressionNode.NumberLiteralNode.FloatLiteralNode -> listOf()
        is ExpressionNode.NumberLiteralNode.IntegerLiteralNode -> listOf()
        is ExpressionNode.OperationNode -> documentSymbols(value.left) + documentSymbols(value.right)
        is ExpressionNode.StatementExpressionNode -> documentSymbols(value.statement)
        is ExpressionNode.StringLiteralNode -> emptyList()
        is ExpressionNode.VariableLiteralNode -> listOf(
            DocumentSymbol(
                value.name,
                SymbolKind.Variable,
                range(value.location),
                range(value.location),
                null,//TODO: add infos
                mutableListOf()
            )
        )
    }
}


